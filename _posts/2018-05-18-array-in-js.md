---
layout: post
title: "О некоторых особенностях массивов в JavaScript"
description: "Особенности работы с массивами в JavaScript. Работа с массивами в JavaScript. Массивы JS "
author: "Paul Finch"
tags: ["JavaScript"]
image: array.jpg
---

Язык JavaScript сегодня развился достаточно серьезно. В нем постепенно исправляются явные "косяки", появляются новые методы и даже структуры данных(*тип __Symbol__ в ES6*). Но странностей(недоработок) тут также хватает. Некоторые из них порой могут запутать новичков...

<!--excerpt-->

<br/>
### Определение

Итак, массив не является отдельным, примитивным типом данных в JavaScript. Это своего рода разновидность объекта(*Object*) c дополнительными возможностями. Хранят в них различные упорядоченные списки данных: количество пользователей или групп, список постов в группе и т.д.

С помощью оператора __*typeof x*__ посмотрим на тип массива. Все верно - объект.
```javascript
let array = []; // массив
let obj = {}; // объект

console.log( typeof array ) // Object
console.log( typeof obj ) // Object
```
<br/>
### Длина массива

Одна из первых особенностей - длина(размер) массива. Она запросто может не соответствовать фактическому количеству элементов в нем.(_в языке Python например такого нет_). Посмотрим на примере.

```javascript
let arr = [];
arr[0] = 2;
arr[1] = 3;
console.log( 'Длинна массива = ', arr.length ) // Длинна массива = 2

// А теперь сделаем следующее
arr[7] = 4;
console.log( 'Длинна массива = ', arr.length ) // Длинна массива = 8
```
После присваивания 7-ому порядковому элементу массива значения 4, длинна массива увеличилась, и теперь равна 8. Если вывести массив в консоль, то мы увидим следующее:
```javascript
// [2, 3, undefined, undefined, undefined, undefined, undefined, 4]
console.log( arr )
``` 
В определенных случаях это может вызвать затруднения, поэтому можем быстро "набросать" метод, который возвращает массив с фактически имеющимися элементами, и заодно расширим функционал глобального объекта *Array*.
```javascript
Array.prototype.clean = function clean() {
    let res = [];

    // проверяем, имеется ли элемент в массиве
    for( let elem of this) {
        if ( elem ) res.push(elem);
    } return res;
}

// Проверим
let array = [];
array[0] = 5;
array[1] = '25';
array[5] = 100;

console.log( array.clean() ) // [5, '25', 100]
```

Но у такого решения есть две проблемы:
1. Если элемент "falsy" - т.е. его приведение к булевому значению будет равно `false`, то проверка в `if` не сработает и элемент потеряется.
2. Т.к. прототип массива - `Array.prototype` - это глобальный объект, все его свойства так же распространяются глобально, из-за чего могут возникнуть коллизии имен, если разные скрипты захотят добавить и воспользоваться разные свойства с одинаковыми именами. Это можно решить одним из трех способов:
    1. Создать ключ - имя свойства через `Symbol`, хранить его в замыкании необходимого скрипта и обращаться через квадратные скобки.
    2. Отнаследоваться от класса `Array`, добавить ему необходимые методы и использовать, где нужно, новый класс.
    3. Создать отдельную функцию, не привязанную к глобальному классу.

Решение вышеперечисленных проблем может выглядеть так:

> согласно спецификации EcmaScript (на которой построен JavaScript), итерация по массиву через внутренние функциональные методы вызывает callback метода только для не пустых значений.

```javascript
function clearArray(array) {
  let newArray = [];
  array.forEach(elem => newArray.push(elem));
  return newArray;
}

// Проверим
let array = [];
array[0] = 5;
array[1] = '25';
array[5] = 100;

console.log( clearArray(array) ) // [5, '25', 100]
```

<br/>
### Передача свойств по ссылке

Как уже говорилось выше, массивы = разновидность объектов. Соответственно при копировании переменной с массивом – копируется ссылка на него.
```javascript
let arr = [1,2,3];
let arrTwo = arr; // записываем в переменную наш массив
arrTwo[2] = 'Wrong'

console.log( arr ) // [1, 2, "Wrong"]
console.log( arrTwo ) // [1, 2, "Wrong"]
```

А как же скопировать массив, чтобы работать с ним как с новым? Чтобы не было передачи свойств по ссылке? Легко. Можно использовать оператор [spread](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Spread_operator) из ES6
```javascript
let arr = [1,2,3];
let arrTwo = [...arr]; // оператор ... (spread)
arrTwo[2] = 'Wrong'

console.log( arr ) // [1, 2, 3]
console.log( arrTwo ) // [1, 2, "Wrong"]
```
Тут стоит сказать об одном ограничении. Оператор __*spread*__ нельзя использовать для копирования многомерных массивов

P.S. Да, я знаю что это все банально и просто, но некоторые новички могут упустить это из виду. Кстати, в следующих материалах мы рассмотрим новые типы коллекций в JavaScript: __*Set*__, __*Map*__, а также некоторые полезные методы работы с массивами.

Все об Array читайте [здесь](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)
